# Database Migrations

This document describes how to manage database migrations for ResuBoost AI using Alembic.

## Overview

Alembic is a database migration tool for SQLAlchemy. It allows you to:
- Track schema changes over time
- Apply incremental changes to your database
- Roll back changes if needed
- Keep development, staging, and production databases in sync

## Quick Start

### For New Installations

If you're setting up a fresh database:

```bash
# Apply all migrations to create the schema
make db-upgrade
```

### For Existing Databases

If you have an existing database created with `init_db()`:

```bash
# Mark the database as already at the initial migration
make db-stamp REV="0001"
```

This tells Alembic that your database already has the schema from the initial migration.

## Migration Commands

All commands are available via the Makefile from the project root:

| Command | Description |
|---------|-------------|
| `make db-migrate MSG="description"` | Create a new migration |
| `make db-upgrade` | Apply all pending migrations |
| `make db-downgrade` | Rollback the last migration |
| `make db-history` | Show migration history |
| `make db-current` | Show current migration revision |
| `make db-stamp REV="revision"` | Mark database at a specific revision |

You can also run Alembic directly from the `backend/` directory:

```bash
cd backend

# Create a new migration
alembic revision --autogenerate -m "add new feature"

# Apply migrations
alembic upgrade head

# Rollback one migration
alembic downgrade -1

# Rollback to specific revision
alembic downgrade 0001

# View history
alembic history --verbose

# View current revision
alembic current
```

## Creating Migrations

### Automatic (Autogenerate)

Alembic can automatically detect changes to your SQLAlchemy models:

```bash
make db-migrate MSG="add user preferences table"
```

This will:
1. Compare your current models to the database schema
2. Generate a migration file with the detected changes
3. Save it in `backend/alembic/versions/`

**Always review generated migrations before applying them!**

### Manual

For complex changes that autogenerate can't detect (data migrations, custom SQL):

```bash
cd backend
alembic revision -m "migrate user data to new format"
```

Then edit the generated file manually.

## Migration Workflow

### Development

1. Make changes to your SQLAlchemy models
2. Create a migration: `make db-migrate MSG="describe your changes"`
3. Review the generated migration file
4. Apply the migration: `make db-upgrade`
5. Test your changes
6. Commit both the model changes and migration file

### Deployment

1. Pull the latest code including new migrations
2. Apply pending migrations: `make db-upgrade`
3. Start the application

## Best Practices

### DO

- **Review autogenerated migrations** - They may miss some changes or include unwanted ones
- **Test migrations** on a copy of production data before deploying
- **Use descriptive migration messages** - They become the filename
- **Keep migrations small** - One logical change per migration
- **Include both upgrade and downgrade** - Always implement the rollback
- **Commit migrations with related code changes** - Keep them together

### DON'T

- **Don't edit migrations after they're applied** to other environments
- **Don't delete migrations** that have been applied anywhere
- **Don't skip migrations** - Apply them in order
- **Don't put business logic in migrations** - Just schema changes

### Naming Convention

Migration files are named: `YYYYMMDD_HHMMSS_<revision>_<slug>.py`

Example: `20260123_143052_abc123_add_user_preferences.py`

## Handling SQLite Limitations

SQLite has limited ALTER TABLE support. Alembic handles this with "batch mode":

- Column type changes
- Adding/removing constraints
- Renaming columns

These operations are handled automatically via `render_as_batch=True` in `env.py`.

For batch operations, Alembic:
1. Creates a new table with the desired schema
2. Copies data from the old table
3. Drops the old table
4. Renames the new table

## Handling PostgreSQL in Production

The configuration supports both SQLite (development) and PostgreSQL (production):

```bash
# Set DATABASE_URL for PostgreSQL
export DATABASE_URL="postgresql://user:password@localhost/resuboost"

# Run migrations
make db-upgrade
```

## Troubleshooting

### "Target database is not up to date"

Your database is behind. Apply pending migrations:
```bash
make db-upgrade
```

### "Can't locate revision identified by..."

The alembic_version table references a missing migration. This can happen if:
- Migrations were deleted
- Wrong branch of code

Fix by stamping to a known revision:
```bash
make db-stamp REV="head"
```

### "Revision not found"

The specified revision doesn't exist. Check available revisions:
```bash
make db-history
```

### Migration has no changes

Autogenerate didn't detect your changes. This can happen with:
- Data-only migrations
- Changes to indexes
- Some constraint changes

Create a manual migration and add the operations yourself.

### Database is out of sync

If your database schema doesn't match any migration:

1. Back up your data
2. Compare your schema to the expected schema
3. Either:
   - Create a migration for the differences
   - Reset and re-apply all migrations (development only)

## Migration File Structure

```python
"""Description of the migration

Revision ID: abc123
Revises: previous_revision
Create Date: 2026-01-23 14:30:52.123456
"""
from alembic import op
import sqlalchemy as sa

revision = 'abc123'
down_revision = 'previous_revision'

def upgrade():
    # Apply changes
    op.create_table('new_table', ...)
    op.add_column('existing_table', sa.Column('new_col', sa.String()))

def downgrade():
    # Reverse changes
    op.drop_column('existing_table', 'new_col')
    op.drop_table('new_table')
```

## Common Operations

### Add a new table

```python
def upgrade():
    op.create_table(
        'user_preferences',
        sa.Column('id', sa.Integer(), primary_key=True),
        sa.Column('user_id', sa.Integer(), sa.ForeignKey('users.id')),
        sa.Column('theme', sa.String(50), default='light'),
        sa.Column('created_at', sa.DateTime(), default=sa.func.now())
    )
    op.create_index('ix_user_preferences_user_id', 'user_preferences', ['user_id'])

def downgrade():
    op.drop_index('ix_user_preferences_user_id')
    op.drop_table('user_preferences')
```

### Add a column

```python
def upgrade():
    op.add_column('users', sa.Column('phone', sa.String(20), nullable=True))

def downgrade():
    op.drop_column('users', 'phone')
```

### Add an index

```python
def upgrade():
    op.create_index('ix_jobs_company_status', 'job_applications', ['company', 'status'])

def downgrade():
    op.drop_index('ix_jobs_company_status')
```

### Data migration

```python
from sqlalchemy.sql import table, column

def upgrade():
    # Define table for data operations
    users = table('users', column('status', sa.String))

    # Update data
    op.execute(users.update().where(users.c.status == None).values(status='active'))

def downgrade():
    pass  # Data migrations are often not reversible
```

## Environment Variables

The migration system uses these environment variables:

| Variable | Description | Default |
|----------|-------------|---------|
| `DATABASE_URL` | Database connection string | `sqlite:///./data/resume_ai.db` |
| `TESTING` | Set to `true` to bypass secret key validation | `false` |

## Files Overview

```
backend/
├── alembic.ini              # Alembic configuration
├── alembic/
│   ├── env.py               # Migration environment setup
│   ├── script.py.mako       # Migration file template
│   └── versions/            # Migration files
│       └── 20260123_000000_0001_initial_schema.py
└── MIGRATIONS.md            # This file
```
